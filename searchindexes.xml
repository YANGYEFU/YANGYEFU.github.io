<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>关于考试的记录</title><url>/post/%E5%85%B3%E4%BA%8E%E8%80%83%E8%AF%95%E7%9A%84%E8%AE%B0%E5%BD%95/</url><categories/><tags><tag>考试</tag><tag>考公</tag><tag>编制</tag></tags><content type="html">记录考试相关的东西 2020年国考 2019-11-24 国家公务员考试
真真假假复习了一个半月，认真做了08年到19年国考真题，复习的时候正常情况110分钟能做完120题，剩下10道数量关系
考试时间没有把握好，临近考试结束15分钟，剩下了数量关系和资料分析，剩下的时间涂完了答题卡，开始做资料分析，最后没做完
报考的是重庆区县国税，考完在粉笔估分，行测56.7，感觉凉凉
2020-01-07 成绩公布
行测 62.1，申论 67，总分 129.1
2020-01-08 国考面试名单及最低分数线
岗位招1人，招录比1:3，进面最低分130.2
2020年西部计划 2020-06-09 重庆市某区县西部计划考试
上午笔试，下午面试
笔试涉及到了团情、时政、西部计划、公文写作、活动策划、区情
面试问到了2个问题：
对西部计划有什么了解？ 进入西部计划后有什么规划？
2020-06-12 成绩公布
总成绩 79.4，排名31？
2020-07-02 预录取
接到区团委电话，西部计划预录取（区县计划）
在出成绩前，接到过区团委电话，询问我是否会微信公众号运营，为此特地看了一些公众号运营的东西
在集中培训前，接到区土地和房屋征收中心人事科电话，要求培训前到线下见个面，猜想应该是已经分配好岗位了
2020-07-20 集中培训
受今年疫情影响，西部计划培训改为3天的云培训
2020-07-20 派遣仪式
20日下午，西部计划派遣仪式，被分配到区土地和房屋征收中心
2020-07-27 正式上岗
被分配到房屋征收科，业务科室
协助副科长做拆迁安全部分工作
协助副科长做信访工作
学习业务知识
2021-07-27 转科室
根据工作安排，到办公室工作，综合科室
计算机相关：故障处理、硬件配置
软件正版化相关工作
日常杂事比较多
2021-11-04 年度考核优秀
重庆市大学生志愿服务西部计划项目管理办公室
关于对杨仁恒等 466 名 2020—2021 年度大学生志愿服务西部计划志愿者年度考核
优秀等次人员表扬的通报
渝项目办〔2021〕26号
2020年三支一扶 2020-07-25 重庆市三支一扶考试
考察综合知识
感觉做得一般，不太适应选择题+一道写作的考试模式
2020-08-17 成绩公布
总分 62.5
岗位：合川区就业和社会保障服务机构，最低进面80.5
2020年选调生 2020-07-26 选调生考试
没有备考，感觉做得还行
2020-08-06 成绩公布
行测 64，申论 70，总分 134
岗位：綦江区综合岗位3，最低进面 134.5
2020年重庆市考 2020-08-22 笔试
感觉题比国考简单，直观的表现是有10分钟做计算题
申论1，有三题，第二题感觉不好写
2020-09-25 成绩公布
行测 63.5，申论 59，总分122.5，排名14
岗位：万州江南新区管理委员会 数据分析职位，最低进面137
2020年合川区卫生事业单位考试 2020-08-29 笔试
80题，单选、多选，判断
考察常识比较多，有较新的时政，也有国考省考中出现过的题
2020-09-04 成绩公布
综合基础知识 71.86
岗位：合川区卫生事业单位-计算机及网络信息管理，最低进面77.48
沙坪坝区2020年下半年公招（选）聘事业单位工作人员 2020-09-26 笔试
岗位：石井坡街道社区事务服务中心-综合管理
综合+管理，管理等于是裸考
綦江区2020下半年公开招聘 2020-11-28 笔试
岗位：东溪中学-高中信息技术教师
遇到了一个经常考试碰到的朋友，同计算机类
2021年国考 2020-11-29 笔试
岗位：浙江省税务局-一级行政执法员（三）
渝中区2021年第一季度公招教育事业单位工作人员 2021-01-31 笔试
岗位：重庆市渝中区两路口小学-小学信息技术教师
只考综合
教师资格证 2021-03-13 笔试
感觉复习得还行，之前 302-教育知识与能力 没有过，这次报了 302-教育知识与能力 和 415-信息技术学科知识与教学能力（高级中学）
2021-04-15 成绩公布
302-教育知识与能力 74
415-信息技术学科知识与教学能力（高级中学） 74
都过了，准备面试，这次报的高中信息技术面试
2021-2022 教师资格证面试及认定
2021-07-15 信息技术
2022-04-29 数学
信息技术、数学已经通过面试、认定，以后可以报考信息技术教师岗位了
2021年重庆市考 2021-03-27 笔试
计算题还是没有时间做，全部选的B
2021-04-26 成绩公布
行测 63.6，申论 50，总分113.6，排名4
岗位：城口县行政事务管理中心（参照）-网络维护岗位，最低进面117.3
排名第4，有点可惜，还是实力不够
2021年上半年重庆市属事业单位公开招聘 2021-05-09 笔试
综合 56，专业 62？
岗位：重庆三峡医药高等专科学校附属中医院-信息技术岗
综合+专业，还在不同考场
合川区2021年公开招聘乡村振兴专业人才 2021-05-21 笔试
岗位：沙鱼镇建设环保服务中心-信息化建设
也只考综合，但是有个作文。末位进面，分差不是很大
2021-06-18 面试
这次是我抽签，岗位排在前面，自己是第1个面试
3个男生1个女生，最后是女生进面，女生笔试第2
綦江区2021年上半年公开招聘 2021-05-22 笔试
岗位：重庆市医科学校
综合+教育公共基础
合川区2021年度上半年公开招聘教育卫生事业单位工作人员 2021-05-29 笔试
岗位：区结合医院-信息科
只考综合
巴南区2021年公开招聘 2021-06-19 笔试
岗位：渝汇路小学-小学信息技术教师
教育综合+专业
2021年三支一扶 2021-06-20 笔试
岗位：就业和社会保障服务机构
综合 60.5，排名 214，最低进面 65
感觉这个排名过于离谱，三支一扶又不是直接有编制，怎么比其他的还卷？
秀山县2021年公开招聘 2021-07-18 笔试
岗位：凤起中学-初中信息技术教师
只靠一科综合，考得不怎么样，但是再也不想去秀山考了
垫江县2021年三季度公开招聘 2021-09-12 笔试
岗位：中学计算机教师
有一说一垫江的牛肉还可以
2021-09-25 面试
低分进面，面试体验一日游
7:50进入考室，被抽签到下午，在候考室真的很无聊
江津区2021年三季度公开招聘 2021-10-10 笔试
岗位：江津五中高中-信息技术教师
2021年下半年重庆市属事业单位公开招聘 2021-10-30 笔试
岗位：江北不动产登记中心-软件设计与数据分析
综合 54，专业 忘了
2022年国考 2021-11-28 笔试
岗位：四川省税务局-一级行政执法员（四）
2022年南岸区上半年公开招聘教育事业单位工作人员 2022-04-23 笔试
岗位：重庆文德中学校
成绩：62
只考一科综合知识，感觉不难，但是感觉是错的
大足区事业单位2022年第一季度公开招聘 2022-06-25 笔试
岗位：大足中学-高中信息技术教师
2022年重庆市考 2022-07-09 笔试
计算题做了一点，申论感觉越学越不行
成绩公布
行测 61.5，申论 45.5，总分107，排名17
岗位：黔江区医疗保障事务中心（参照）
申论越来越不行了，不太理解为什么，感觉不如不学
2022年三支一扶 2022-07-10 笔试
岗位：綦江区医疗卫生机构-岗位11
综合（卫生类） 65，公文写作 58，总分123，排名25
卫生类的综合有些专业常识，不太会，全是猜的
2022年重庆市特岗教师招聘 2022-07-16 笔试
题目感觉很简单，都是些很基础的知识，考完发现自己还是错了很多简单的
2022-07-20 成绩公布
教论 72，专业 73，总分145
岗位：丰都县中学信息技术
特岗一年比一年招的少，去年进面分数是140左右，但是今年面都进不了，真卷
云阳县事业单位2022年三季度公开招聘 2022-08-06 笔试
岗位：云阳县乡镇初中信息技术教师
南川区事业单位2022年第三季度公开招聘 2022-09-17 笔试
类别：综合管理A类
岗位：区卫生健康信息中心-计算机应用
这是重庆市事业单位招聘改革之后的第一次考试，A类和公务员的题目类型差不多，但是成绩一言难尽
九龙坡区事业单位2022年下半年公开招聘 2022-10-30 笔试
岗位：区文化馆-数字文化岗
职测+综合
万州区事业单位2022年三季度公开招聘 2022-09-25 笔试
综合 59，教育公基 64，总分123，排名 1，1:2进面
第一次以第一名进面，但是只能看到自己的排名，看不到第2名的成绩
问了一下各个培训机构，得知第2名在某高正面试培训，这时感觉自己应该稳了，之前九龙坡招2个，女朋友排第2，也是报的高正，成功落败，还好是协议班隔了一个月全额退了
2022-10-26 资格审查
2022-12-31 面试
这次面试基本就是裸考，也没准备啥，平时下班后基本都在玩游戏，也不想看书，不想复习。干啥啥不行，摆烂第一名 唯一的准备是为面试特意买了西服，但是最后还是穿着羽绒服就去了
两个原因：一是真的太冷了。二是女朋友第1名进面，地点在家乡，这里考不上就算了，免得异地
试讲 78.25，结构化 77.30，面试也是排第1
公布成绩才发现第2名笔试和我相差十几分
2023-01-03 体检
2023-01-10 政审
2023-02-04 报道
还没有发正式的聘用文件，单位通知要去报道，应该快了吧，不然算不算打黑工？
2023-02-10 聘用文件
签聘用合同，最低服务5年，第一次合同签3年：2023.2.1-2026.1.31
好像本来是2022年8月的考试，因为疫情把战线拉到了半年</content></entry><entry><title>教育知识与能力</title><url>/post/%E6%95%99%E8%82%B2%E7%9F%A5%E8%AF%86%E4%B8%8E%E8%83%BD%E5%8A%9B/</url><categories/><tags><tag>教育知识与能力</tag><tag>教师资格证</tag></tags><content type="html"><![CDATA[教师资格证相关 一、教育的属性 ​ 1.本质属性：有目的的培育人的社会活动
​ 2.社会属性：
​ （1）永恒性：人在教育在（有人存在教育就会存在）
​ （2）历史性：古今不同（古代教育与现代教育存在差异）
​ （3）相对独立性：
​ 1）历史继承性
​ 2）受其他社会意识形态的影响
​ 3）与政治经济发展不平衡
二、教育的起源 ​ 1.神话起源说：教育是由神创造的（宗教性）
​ 2.生物起源说：教育起源于动物界的生存本能（相关人物：利托尔诺、沛西能）
​ 3.心理起源说：教育起源于儿童对成人的“无意识模仿”（本能，相关人物：孟禄）
​ 4.劳动起源说：教育起源于劳动过程中社会生产需要与人发展需要的辩证统一（相关人物：米丁斯基、凯洛夫）
时间顺序：神话-&gt;生物（正式）-&gt;心理-&gt;劳动
生物、心理起源说：共同点是指向本能，违背了教育的社会性
三、教育的发展（古代教育） ​ 1.奴隶社会
​ （1）中国：
​ 1）夏-商-周：
​ · 学校：庠、序、校 -&gt; 国学、乡学
​ · 内容：六艺（礼、乐、射、御、书、数）
​ · 特点：政教合一，学在官府
​ 2）春秋：
​ · 学校：私学
​ · 特点：学术自由
​ （2）西方
​ 1）古印度：宗教教育（婆罗教、佛教），《吠陀》
​ 2）古埃及：文士学校（以僧为师、以吏为师），文字、书写、执政
​ 3）古希腊：巴斯达（尚武，军事体育），雅典（崇文，和谐发展）
​ 2.封建社会
​ （1）中国：
​ 1）战国：私学，儒墨（百家争鸣）
​ 2）汉代：罢黜百家，独尊儒术（董仲舒），举察制、征辟制
​ 3）魏-晋：九品中正制，上品无寒门，下品无士族
​ 4）隋-唐：科举制（隋炀帝），六学二馆（唐）
​ 5）宋-元-明：书院，四书五经，科举制
​ 6）清末：废科举，兴学堂（1905年）
​ （2）西方（中世纪）：
​ 1）教会学校：七艺（3科：文法、修辞、辩证，4学：算术、几何、天文、音乐）
​ 2）骑士学校：七技
古代教育基本特征：
​ 产生学校：出现了学校（庠、序、校、国学、乡学、私学、书院，文士学校、教会学校、骑士学校）
​ 劳、教脱离：生产劳动与教育脱离（封建社会）
​ 阶级性、等级性：贵族接受教育，人分等级
​ 道统、专制、刻板、象征性：道统-内容，管理专制，方法刻板，教育具有地位的象征性
四、教育学的创立阶段 ​ 1.创立派
​ （1）培根：科学归纳法第一人，首次提出“教育学”因作为一门独立学科
​ （2）夸美纽斯：教育学之父
《大教育学论》 教育学独立的标志
泛智教育：把广泛的自然知识传授给普通的人
系统论述班级授课制方法和实施内容
直观性原则：让学生有直观的感受
​ （3）康德：最早在大学中讲授教育学
​ （4）赫尔巴特：现代教育学之父、科学教育奠基人、传统教育代表人
《普通教育学》标志教育学进一步规范化、科学化
1原则：教育性教学原则（德育，思想教育）
2基础：伦理学、心理学作为教育学的理论基础
3中心：教师中心、教材中心、课堂中心
4阶段：明了、联想、系统、方法
目的：培养良好的社会公民
​ （5）杜威：现代教育代表人、进步教育代表人、实用主义哲学创始人
《民主主义与教育》
新3中心：儿童中心、经验中心、活动中心
4个即：教育即生活、教育即生长、教育即经验，学校即社会
5步教学法：困难-问题-假设-验证-结论
​ 2.自然派
​ （1）卢梭：《爱弥儿》，“自然主义”教育思想
​ （2）裴斯泰洛奇：慈爱的儿童之父
最早提出“教育心理学化”主张（自然）
西方教育史上第一个将“教育与生产劳动相结合”付诸实践
​ 3.其他派
​ （1）洛克：《教育漫话》，提倡“白板说”、“绅士教育”（后天环境）
​ （2）斯宾塞：科学知识最有价值，教育预备生活说（为未来的完满生活）
五、影响人身心发展的因素 ​ 1.遗传：生理上，是物质基础，提供了可能性（遗传决定论夸大了遗传的作用）
​ 2.环境：外部因素，是现实、外部动力
​ 3.学校教育：起主导作用
原因：
​ 学校教育有目的、有计划、有组织，教师接受过严格训练。
​ 学校控制外部带来的影响，学校教育比较全面，规范
表现：
​ 教授社会规范，塑造个性，促进学生发展
​ 4.主观能动性：对客观世界的能动作用，是内部动力，起决定性作用
六、课程的类型 ​ 1.学科属性分类
​ （1）学科课程：学习知识，完整成体系，忽略儿童主体性
​ （2）经验课程：直接经验，重视儿童主体性，无完整体系（杜威，新3中心：儿童中心、经验中心、活动中心）
​ 2.组织方式分类
​ （1）分科课程：即学科课程
​ （2）综合课程：课程中有相互联系的地方（怀特海）
​ 3.实施要求分类
​ （1）必修课程：培养学生共性
​ （2）选修课程：培养学生个性
​ 4.设计、开发、管理主体分类
​ （1）国家课程：中央（部）
​ （2）地方课程：省级（厅）
​ （3）校本课程：学校（老师），不一定需要教材
​ 5.课程任务分类
​ （1）基础型课程：培养基础能力
​ （2）拓展型课程：培养特殊能力（视野，横向拓展）
​ （3）研究型课程：培养探索能力（深入学习，纵向拓展）
​ 6.呈现形式分类
​ （1）显性课程：计划内课程（课表内的课）
​ （2）隐性课程：计划外课程（班风、学风、课表）
七、教学评价 ​ 1.评价功能分类
​ （1）诊断性评价（教学前）：了解学生的准备状况
​ （2）形成性评价（教学中）：改进完善教学（提问、单元测试等方式）
​ （3）总结性评价（教学后）：评价学习成果（期末考试、会考等方式）
​ 2.参照标准分类
​ （1）相对性评价：常模参照（名次）
​ （2）绝对性评价：目标参照评价，有评价的标准
​ （3）个体差异评价：自己的过去或其他方面
​ 3.评价主体分类
​ （1）内部评价：自我评价
​ （2）外部评价：自我之外的专业人员
​ 4.评价方法分类
​ （1）定性评价：性质（根据事实）
​ （2）定量评价：具体数字
八、教育原则 直观性、启发性、思想性与科学性、理论联系实际、循序渐进、因材施教、巩固性、量力性
​ 1.教学过程
直观性：实物直观、模系直观、言语直观（直接经验与间接经验相统一）
启发性：学生主动性，独立思考（产婆术）（教师主导与学生主体相统一）
思想性与科学性：知识+品德（赫尔巴特）（传播知识与思想教育相统一）
理论联系实际：理论+实际，学以致用，知行合一（直接经验与间接经验相统一）
​ 2.个体发展
循序渐进：顺序性
因材施教：个体差异性规律
​ 3.心理学
巩固性：艾宾浩斯遗忘规律
量力性：最近发展区
九、教学方法 讲授法、问答谈话法、谈论法、读书指导法、
参观法、演示法、练习法、实验法、实习作业法、实践活动法、
欣赏教学法、情境教学法、
发现法：学生在教师指导下，发现问题，解决问题（相关人物：布鲁纳）
​ 1.语言分类
​ （1）讲授法：教师使用口头语言系统的向学生传授知识的一种方法
使用最广泛、最基本的教学方法
分类：讲述、讲解、讲读、讲演
能够短时间系统的传授知识，忽视学生主体性
要求：教学语言能够启发学生
​ （2）问答谈话法：教师使用问答方式引导学生获取/巩固知识
复习或启发谈话
有利于因材施教，发挥学生主体性，但需要有知识基础
​ （3）讨论法：学生在教师指导下进行讨论，解决问题
能集思广益，但需要有知识基础
相关名言：相关而善，独学而无友
​ （4）读书指导法：教师指导学生阅读教科书或参考书
培养学生自学能力，不需要教师指定书目
​ 2.直观感知
​ （1）参观法：教师组织学生对实物进行实地参观、研究
分类：准备性参观（获取知识）、并行性参观（巩固知识）、总结性参观（验证知识）
​ （2）演示法：教师通过展示实物、教具，进行演示
主体为教师，指导学生获取知识或巩固知识
​ 3.实际训练
​ （1）练习法：学生运用所学知识独立的进行实际操作
分类：口头练习、书面联系、实际操作练习
目的：巩固知识
​ （2）实验法：学生在教师的指导下，使用仪器学习
学生是主体，目的是获取知识与技能
​ （3）实习作业法：教师指导学生运用所学知识，在校内外实际操作
知识+实地操作，运用知识，形成技巧
​ （4）实践活动法：学生参加社会实践活动，培养能力
从做中学，培养能力
​ 4.情感
​ （1）欣赏教学：教师指导学生体验客观事物的真善美
​ （2）情景教学：教师引入或创设情境，引起学生的情感体验
十、教学的组织形式 个别教学制、班级授课制、分组教学、设计教学法、道尔顿制、特朗普制、翻转课堂
​ 1.个别教学制：教师对学生一一轮流教学（古代）
有利于因材施教，但学生数量有限
​ 2.班级授课制：课堂教学，集体教学方式（最基本、最广泛的教学方式，夸美纽斯）
产生与发展：
​ 世界：1632年，夸美纽斯，《大教学论》
​ 我国：1862年（清末），京师同文馆
特点：班（班级）、课（学科）、时（上课时间）
可以大面积的培养人才，发挥教师的主导作用，发挥学生的集体作用，学生多方面发展。
但学生主体性受限，不利于创造实践能力的培养，难以因材施教。
辅助形式：个别辅导、现场教学
特殊形式：复式教学（两个以上年级编为一个班，一教师教授不同程度的教材），培养学生自学能力
​ 3.分组教学：按学生能力或成绩分组教学
分类：内部分组（班级内）、外部分组（打乱原有班级）
较有利于因材施教（个体、个别差异较小），但难以鉴别能力、差异
​ 4.设计教学法：反对班级授课制，代表人物：克伯屈，认为学生决定学习内容，学生设计
​ 5.道尔顿制：反对班级授课制，代表人物：柏克赫斯特，教师指定参考书，学生自学
​ 6.特朗普制：灵活的课程表，大班上课，小班研究，个别教学
​ 7.翻转课堂：学生在家学习知识，课堂上教师与学生互动、答疑
十一、注意的分类|注意的品质 1.注意的分类
有无目的、是否需要意志力
​ 1）无意注意：无目的，不需要意志力
​ 2）有意注意：有目的，需要意志力
​ 3）有意后注意：有目的，不需要意志力
2.注意的品质
​ 1）注意的广度：指范围、数量
​ 2）注意的稳定性：指时间。
注意的分散：指分心，消极
​ 3）注意的分配：指同时。积极
​ 4）注意的转移：积极、有意义
注意的迁移：人的注意不能长时间维持固定不变，经常出现周期性的加强或减弱
十二、感觉现象 1.同一感觉
​ 1）感觉适应：视觉适应（暗适应提高，明适应降低），嗅觉适应，肤觉适应
​ 2）感觉对比：同时对比，继时对比
​ 3）感觉后效：正后像（一致），负后像（不一致）
2.不同感觉
​ 1）感觉补偿作用：当某种感觉受损或缺失后,其它感觉的感受性提高以进行补偿的现象
​ 2）联觉：通过一种感觉联想到另一种感觉
十三、知觉的基本特征 1.选择性：对象和背景的关系
2.整体性：部分与整体的关系
3.理解性：根据知识经验
4.恒常性：条件改变，直觉对象不变
十四、记忆的分类 1.按记忆内容/经验对象划分
​ 1）形象记忆：对感知的记忆
​ 2）情绪记忆：对情感的记忆
​ 3）逻辑记忆：对抽象内容的记忆
2.按记忆时间长短划分
​ 1）瞬时记忆：容量较大，1秒内，基本物理编码
​ 2）短时记忆（工作记忆）：5-9组块，1分钟内，听觉为主，视觉为辅编码
​ 3）长时记忆：容量很大，1分钟以上，意义编码为主（语义、表象编码）
3.图尔文将长时记忆
​ 1）情景记忆：具体场景，跟时间地点有关
​ 2）语义记忆：语言
4.信息加工和储存内容
​ 1）陈述性记忆：是什么，为什么，怎么样
​ 2）程序性记忆：怎么做（顺序）
十五、想象的分类 1.无意想象：无目的，不自觉 eg：云、山、梦
2.有意想象：有目的，自觉
​ 1）再造想象：读者对语义、图像的想象
​ 2）创造想象：作者独立、首创的想象
幻想：理想（可实现）、空想（不可实现）
十六、思维的分类 1.凭借物、发展水平不同
​ 1）直观动作思维：动作
​ 2）具体形象思维：表象
​ 3）抽象逻辑思维：语言符号
2.逻辑性思维
​ 1）直觉思维：突然顿悟
​ 2）分析思维：逐步分析
3.指向性划分
​ 1）辐合思维：唯一答案
​ 2）发散思维：多个答案
4.创新性划分
​ 1）常规性思维：固定模式
​ 2）创新性思维：新颖方法
十七、强化原理（斯金纳） 1.强化：使行为发生频率增加
​ 1）正强化：增加愉悦
​ 2）负强化：减少厌恶
2.惩罚|消退：使行为发生频率减少
​ 1）惩罚：增加厌恶
​ 2）消退：不理睬、冷处理
十八、动机分类（奥苏贝尔） 1.认知内驱动力（稳定）：学生渴望了解和理解，要求掌握知识（内部）
2.自我提高内驱动力：为获得相应地位（外部）’
3.附属内驱动力：为获取他人赞许获认可（外部）
十九、归因理论（韦纳，三维度六因素） 三维度：因素来源、稳定性、可控性
六因素：能力、努力程度、工作难度、运气、身心状况、外界环境
1.成败归因维度
因素来源（内部）：能力、努力程度、身心状况
稳定性（稳定）：能力、工作难度
可控制性（可控）：努力程度
2.归因指导理论：努力归因+现实原因
3.习得性无助（归因错误导致）
​ 1）学习动机降低（不想学习）
​ 2）认知出现障碍（怀疑自己）
​ 3）情绪失调
二十、马洛斯需要层次理论 1生理需要（最低）&ndash;&gt;2安全需要&ndash;&gt;3归属与爱需要&ndash;&gt;4尊重需要&ndash;&gt;5求知需要&ndash;&gt;6审美需要&ndash;&gt;7自我实现（最高）
1.匮乏性需要：生理、安全、归属与爱、尊重
2.成长性需要：求知、审美、自我实现
3.需要具有层次性、可跨越性：由低到高（层次性），跨越某些需要（可跨越性）
4.多重性：1个主要，多个次要
二十一、学习迁移的分类 学习迁移指一种学习对另一种学习的影响
1.性质
​ 1）正迁移：积极的促进作用
​ 2）负迁移：消极的阻碍作用
2.方向（时间上）
​ 1）顺向迁移：前对后的影响
​ 2）逆向迁移：后对前的影响
3.抽象水平概括
​ 1）水平迁移（横向）：同意抽象概括水平（并列）
​ 2）垂直迁移（纵向）：不同抽象概括水平
4.内容
​ 1）一般迁移：原理、方法、策略、态度对另一种学习的影响
​ 2）具体迁移（特殊）：具体的特殊经验直接迁移到另一种学习中
5.所需内在心理机制
​ 1）同化性迁移：不改变原有认知结构
​ 2）顺应性迁移：调整但不改变原有认知结构
​ 3）重组性迁移：重组原有认知结构（打乱）
二十二、学习策略 多种学习方法的一种综合体现
1.认知策略：
​ 1）复述策略：机械的重复
​ 2）精加工策略：理解（记忆术、口诀）
​ 3）组织策略：归纳、整理（表格）
2.元认知策略
3.资源认知策略
二十三、认知发展阶段理论（皮亚杰） 1.感知运动阶段（0-2岁）
​ 1）低级行为方式感知（感觉、动作）
​ 2）获得客体永恒性（9-12个月）&ndash;&gt;寻找不在眼前的事物
2.前运算阶段（2-7岁）
​ 1）“万物有灵论”（泛灵论）
​ 2）一切以自我为中心（三山实验）
​ 3）思维具有不可逆性
​ 4）没有守恒概念
​ 5）判断事物只能运用一个标准或维度
3.具体运算阶段（7-11岁）
​ 1）形成守恒观念（标志）
​ 2）思维运算必须有具体事物的支持，可简单抽象思维
​ 3）思维具有可逆性
4.形式运算阶段（11-16岁）
​ 1）逻辑推理，归纳或演绎（钟摆实验）
​ 2）能理解符号意义，隐喻或直喻，能做一定概括
​ 3）思维具有可逆性、补偿性和灵活性
二十四、情感分类 1.道德感：道德
2.理智感：智力活动
3.美感：审美标准
二十五、气质的类型 1.胆汁质：热情、冲动
2.多血质：活泼好交际、耐性差
3.黏液质：稳重、死板
4.抑郁质：观察力强，敏感多疑
二十六、道德发展理论（皮亚杰、柯尔伯格） 柯尔伯格道德发展论
1.道德两难故事法：汉斯偷药
2.三水平六阶段论
​ 1）前习俗水平（10岁前）
惩罚与服从定向阶段：是否惩罚
相对功利道德定向阶段：是否有利
​ 2）习俗水平（10-20岁）
寻求认可定向阶段：别人认可
遵守法规和秩序定向阶段：法制意识
​ 3）后习俗阶段（20岁后）
社会契约定向阶段：大服从多数
普遍伦理定向阶段：道德发展，最高阶段（原则、良心）
]]></content></entry><entry><title>leetcode初级算法</title><url>/post/leetcode-%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95/</url><categories/><tags><tag>初级算法</tag></tags><content type="html"><![CDATA[LeetCode算法题 一、数组 1.从排序数组中删除重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。
**已知条件或要求：**1）数组已排序；2）不使用额外数组空间；3）原地修改
思路 1）设置新数组的索引为i，i=0; 2）遍历输入数组nums[]，当前项为num，当nums[i] != num,说明输入数组nums[i]与当前项num不重复，使nums[++i]=num; 3）遍历结束，新数组为nums[0]&ndash;nums[i]，数组长度为i+1。
代码
class Solution { public int removeDuplicates(int[] nums) { int i=0; for (int num:nums){ if(nums[i]!=num){ nums[++i]=num; } } return i+1; } } 2.买卖股票的最佳时机 II 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
思路 1）要想获取利润，天数至少为2； 2）买卖原则：第i天股票价格低于第i+1天时，购入股票，第i+1天卖出。
代码
class Solution { public int maxProfit(int[] prices) { //天数小于2，利润为0 if(prices.length&lt;2){ return 0; } //买入价格，初始为第一天价格 int b=prices[0]; //卖出价格，初始为第一天价格 int s=prices[0]; //利润 int bs=0; for(int i=0;i&lt;prices.length;i++){ //当前价格大于买入价格时，卖出股票，设置为卖出价格，计算累计利润，预买入当前股票 if(b&lt;prices[i]){ s=prices[i]; bs+=s-b; b=prices[i]; } //当前价格小于卖出价格时，说明股票降价，预买入当前股票，设置更新买入价格和卖出价格 if(s&gt;prices[i]){ b=prices[i]; s=prices[i]; } } return bs; } } 3.旋转数组 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
思路 1)当数组长度小于2时不需要操作； 2)原数组元素位置为i，移动后，原数组位置为**(i+k+len)%len**。 3)克隆数组,遍历数组进行赋值。
代码
class Solution { public void rotate(int[] nums, int k) { int len=nums.length; //输入数组长度小于2 if(len&lt;2){ return; } int[] clo=nums.clone(); for(int i=0;i&lt;len;i++){ nums[(i+k+len)%len]=clo[i]; } } } 4.存在重复 给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。
思路 1）数组长度小于2时，不存在重复元素； 2） 方案一：数组排序，遍历数组，当第i个元素与第i-1个元素相同，存在重复元素，即nums[i]==nums[i-1]； 方案二：遍历数组，将数组元素存入HashSet，判断HashSet的size()与数组length是否相等，相等则存在相同元素。
代码
class Solution { public boolean containsDuplicate(int[] nums) { if(nums.length&lt;2){ return false; } Arrays.sort(nums); for(int i=1;i&lt;nums.length;i++){ if(nums[i]==nums[i-1]){ return true; } } return false; } /* public boolean containsDuplicate(int[] nums) { if(nums.length&lt;2){ return false; } Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); for(int n:nums){ set.add(n); } return set.size()!=nums.length; } */ } 5.只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
思路 1）数组排序，2个元素为一组，当nums[i]!=nums[i-1]，**nums[i-1]**为只出现一次的元素。
代码
class Solution { public int singleNumber(int[] nums) { Arrays.sort(nums); for(int i=1;i&lt;nums.length;i+=2){ if(nums[i]!=nums[i-1]){ return nums[i-1]; } } return nums[nums.length-1]; } } 6.两个数组的交集 II 给定两个数组，编写一个函数来计算它们的交集。
思路 1）设置nums1[]为短数组，nums2[]为长数组； 2）将nums2[]添加进test，遍历nums1[]，当前项为value，当test中存在value时，从test中移除，并将value添加进res，最后res中保存的为数组交集。
代码
class Solution { public int[] intersect(int[] nums1, int[] nums2) { if (nums1.length &lt; nums2.length) { return intersect(nums2, nums1); } //存放交集 List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); //存放长数组 List&lt;String&gt; test = new ArrayList&lt;&gt;(); for (int i:nums2) { test.add(i+&#34;&#34;); } //当test中存在value时，从test中移除，并将value添加进res for (int value : nums1) { if (test.contains(value+&#34;&#34;)) { test.remove(value+&#34;&#34;); res.add(value); } } int[] re = new int[res.size()]; for (int i = 0; i &lt; re.length; i++) { re[i] = res.get(i); } return re; } } 7.加一 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。
思路 1）反向遍历digits[],为当前项+1，当前项小于10时，跳出循环； 2）遍历digits[]，使每个元素等于自身对10取余； 3）当digits[0]!=0,说明首位不需要进一，直接返回digits[];反之，new一个新数组res,长度为digits长度加1，使res[0]=1,后续元素复制digits，返回res。
代码
class Solution { public int[] plusOne(int[] digits) { //反向遍历digits[],为当前项+1，当前项小于10时，跳出循环 for (int i = digits.length - 1; i &gt;= 0; i--) { digits[i]=digits[i]+1; if (digits[i] &lt;10) { break; } } //使每个元素等于自身对10取余 for (int i = 0; i &lt; digits.length; i++) { digits[i]=digits[i]%10; } //当digits[0]!=0,说明首位不需要进一，直接返回digits[] if (digits[0] != 0) { return digits; } //首位为0，需要进1 int[] res = new int[digits.length+1]; res[0]=1; System.arraycopy(digits, 0, res, 1, res.length - 1); return res; } } 8.移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。
思路 1)遍历数组nums，当nums[i]==0，移动到nums[len]，len&ndash;；否则i++。
代码
class Solution { public void moveZeroes(int[] nums) { int tmp=0; int len = nums.length-1; for (int i = 0; i &lt; len;) { //nums[i]==0,移动到nums[len]，len-- if (nums[i] == 0) { nums[i] = nums[len]; nums[len] = 0; len--; for (int j = i, k = len; j &lt; k; j++) { tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; } }else { //nums[i]！=0，开始检查i+1项 i++; } } } 9.两数之和 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。
思路 1）将nums[]两两相加的和作为key，两个下标作为value存入hashmap； 2）当key值为target，value不为空时，返回value。
代码
class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, int[]&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length-1; i++) { for (int j = i + 1; j &lt; nums.length; j++) { map.put(nums[i] + nums[j], new int[]{i, j}); if (map.get(target) != null) { return map.get(target); } } } return null; } } 10.有效的数独 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 数独部分空格内已填入了数字，空白格用 &lsquo;.&rsquo; 表示。
思路 1）遍历数独，mapRow、mapCol分别记录每行/列中存在的数字，mapBox[]记录九个九宫格中存在的数字； 2）当检测到存在行/列/九宫格出现重复数字时，返回false。遍历结束，返回true。
代码
class Solution { public boolean isValidSudoku(char[][] board) { Map&lt;Character, Integer&gt; mapRow = new HashMap&lt;&gt;(9); Map&lt;Character, Integer&gt; mapCol = new HashMap&lt;&gt;(9); Map&lt;Character, Integer&gt;[] mapBox = new HashMap[9]; for(int i=0;i&lt;9;i++){ for (int j = 0; j &lt; 9; j++) { //遍历每一行，添加进hashmap，记录每个char出现的次数 if (!setMap(board, i, j, mapRow)) { return false; } //遍历每一列，添加进hashmap，记录每个char出现的次数 if (!setMap(board, j, i, mapCol)) { return false; } //遍历每一个九宫 int index=((i / 3) * 3 + j / 3); if(mapBox[index]==null){ mapBox[index]= new HashMap&lt;&gt;(9); } if (!setMap(board, i, j, mapBox[index])) { return false; } } mapRow.clear(); mapCol.clear(); } return true; } boolean setMap(char[][] board, int i, int j, Map&lt;Character, Integer&gt; map) { if (board[i][j]!=&#39;.&#39;&amp;&amp; map.containsKey(board[i][j])) { return false; } else { map.put(board[i][j], 1); } return true; } } 11.旋转图像 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。
思路 1）顺时针旋转90°，行变换+对角线变换；
代码
class Solution { public void rotate(int[][] matrix) { //对角线变换 for (int i = 0, q = matrix.length; i &lt; matrix.length; i++) { for (int j = 0, n = matrix.length - 1; j &lt; matrix.length - i &amp;&amp; n &gt;= i; j++, n--) { swapDig(matrix, i, j, n); } } //行变换 for (int i = 0; i &lt; matrix.length/2; i++) { for (int j = 0; j &lt; matrix.length; j++) { swapRow(matrix, i, j); } } } void swapDig(int[][] matrix,int i, int j, int n) { int q = matrix.length - i - 1; int tmp = matrix[n][q]; matrix[n][q] = matrix[i][j]; matrix[i][j] = tmp; } void swapRow(int[][] matrix,int i, int j) { int q = matrix.length - i - 1; int tmp = matrix[q][j]; matrix[q][j] = matrix[i][j]; matrix[i][j] = tmp; } } 二、字符串 1.反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。
思路 1）原地转法
代码
class Solution { public void reverseString(char[] s) { int len = s.length - 1; for (int i = 0; i &lt; s.length/2; i++) { char tmp = s[i]; s[i] = s[len - i]; s[len - i] = tmp; } } } 2.整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。
思路 1)tmp = tmp * 10 + (x % 10);
代码
class Solution { public int reverse(int x) { int tmp = 0; for (int i = (Math.abs(x) + &#34;&#34;).length()-1; i &gt;= 0; i--) { tmp = tmp * 10 + (x % 10); x /= 10; if (tmp == 2147483647 || tmp == -2147483648) { return 0; } } return tmp; } } 3.字符串中的第一个唯一字符 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
思路 1)将s每个字符存入hashmap，记录次数； 2)遍历s，当前项在map中次数为1时，返回索引； 3）遍历结束，返回-1.
代码
class Solution { public int firstUniqChar(String s) { Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1); } for (int i = 0; i &lt; s.length(); i++) { if (map.get(s.charAt(i)) == 1) { return i; } } return -1; } /* public int firstUniqChar1(String s) { char[] ch = new char[26]; for (int i = 0; i &lt; s.length(); i++) { ch[s.charAt(i) - &#39;a&#39;]++; } for (int i = 0; i &lt; s.length(); i++) { if (ch[s.charAt(i) - &#39;a&#39;] == 1) { return i; } } return -1; } public int firstUniqChar0(String s) { int end = s.length(); int index = 0; int tmp = 0; for (int i = 0; i &lt; end; i++) { index = 0; for (int j = 0; j &lt; end; j++) { if (i == j) { j++; } tmp = s.charAt(i) - s.charAt(j); if (tmp != 0 &amp;&amp; index == end - 2) { return i; } else if (tmp == 0) { break; } else if (i == end - 1 &amp;&amp; index == end - 2) { return i; } else { index++; } } } return -1; } */ } 4.有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 说明: 你可以假设字符串只包含小写字母。 思路 1）字母异位，长度相同，排除长度不同的情况 2）sh[]和th[]分别存放字符串s、t中每个字母出现的次数 3）若出现的次数不同，返回false，反之返回true
代码
class Solution { public boolean isAnagram(String s, String t) { //长度相同 if (s.length() == t.length()) { char[] sh = new char[26]; char[] th = new char[26]; //分别记录s、t中字母出现次数 for (int i = 0; i &lt; s.length(); i++) { sh[s.charAt(i)-&#39;a&#39;]++; th[t.charAt(i)-&#39;a&#39;]++; } //比较各字母出现次数，不同返回false for (int i = 0; i &lt; sh.length; i++) { if (sh[i] != th[i]) { return false; } } }else { //长度不同，直接返回false return false; } return true; } /* public boolean isAnagram0(String s, String t) { if (s.length() == t.length()) { Map&lt;Character, Integer&gt; mapS = new HashMap&lt;&gt;(); Map&lt;Character, Integer&gt; mapT = new HashMap&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) { mapS.put(s.charAt(i), mapS.getOrDefault(s.charAt(i), 0) + 1); mapT.put(t.charAt(i), mapT.getOrDefault(t.charAt(i), 0) + 1); } for (Map.Entry&lt;Character, Integer&gt; entry : mapS.entrySet()) { if (!mapT.containsKey(entry.getKey()) || !mapT.get(entry.getKey()).equals(entry.getValue())) { return false; } } }else { return false; } return true; } */ } 5.验证回文字符串 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。
思路 1）筛选出字母、数字 2）将字母转换为全部小写/大写 3）正、反向比对，判断是否为回文串
代码
class Solution { public boolean isPalindrome(String s) { if (&#34;&#34;.equals(s)) { return true; } //用于保存正向和反向的字符串 char[] forword = new char[s.length()]; char[] reverse = new char[s.length()]; //获得筛选后的正向和反向数组 assArr(forword, s,true); assArr(reverse, s,false); //比较正向数组与反向数组是否相同 for (int i = 0; i &lt; forword.length; i++) { if (forword[i] != reverse[i]) { return false; } } return true; } /** * 保留字符串中字母、数字，并将字母转换为小写，结果存入数组 * @param arr 用于保存结果 * @param s 输入字符串 * @param fr true正序保存结果；false反序保存结果 * * @Creator: Yang YeFu * @Date: 2020/2/2 17:14 * * @Modify: Yang YeFu * @Date: 2020/2/2 17:14 */ void assArr(char[] arr,String s,boolean fr) { boolean flag; char ch = &#39; &#39;; int len = s.length()-1; for (int i=0,j=0;i&lt;s.length();i++) { //将大写字母转换为小写 if (fr) { //正序 ch=convertToLow(s.charAt(i)); } else { //反序 ch = convertToLow(s.charAt(s.length() - i - 1)); } //过滤出字母和数字 flag = (ch - &#39;0&#39; &lt; 10 &amp;&amp; ch - &#39;0&#39; &gt;= 0) || (ch - &#39;a&#39; &lt; 26 &amp;&amp; ch - &#39;a&#39; &gt;= 0) || ch == &#39; &#39;; if (flag) { if (ch == &#39; &#39;) { //跳过空格 arr[len--] = ch; } else { arr[j++] = ch; } } } } char convertToLow(char ch) { if (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) { return (char) (ch + 32); } return ch; } /* public boolean isPalindrome0(String s) { //使用正则进行筛选 String t = s.replaceAll(&#34;\\W&#34;, &#34;&#34;).toLowerCase(); for (int i = 0,j=t.length()-1; i &lt;= j; i++,j--) { if(t.charAt(i) !=t.charAt(j)){ return false; } } return true; } */ } 6.字符串转换整数 (atoi) 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。
思路 1)找到开始位置，判断正负 2)将字符转换为数字，当字符部位数字时结束 3)判断是否溢出，数值范围为 [−231, 231 − 1]
代码
class Solution { public int myAtoi(String str) { //无效字符串 if (str == null||str.length() == 0) { return 0; } char ch = &#39; &#39;; //记录正负 int flag = 1; //记录开始位置 int i = 0; double res = 0; //寻找开始位置 for (; i &lt; str.length(); i++) { ch = str.charAt(i); if (ch != &#39; &#39;) { if (ch == &#39;+&#39; || ch == &#39;-&#39; || (ch - &#39;0&#39; &lt; 10 &amp;&amp; ch - &#39;0&#39; &gt;= 0)) { if (ch == &#39;-&#39;) { flag = -1; break; } if (ch == &#39;+&#39;) { break; } i--; break; }else { return 0; } } } //计算数值 for (int j = i + 1; j &lt; str.length() ; j++) { ch = str.charAt(j); if (ch - &#39;0&#39; &lt; 10 &amp;&amp; ch - &#39;0&#39; &gt;= 0) { res = res * 10 + ch - &#39;0&#39;; } else { break; } } //判断溢出 if (res != 0) { res = flag * res; if (res &lt; Integer.MIN_VALUE) { return Integer.MIN_VALUE; } else if (res &gt; Integer.MAX_VALUE) { return Integer.MAX_VALUE; } else { return (int) res; } } return 0; } /* public int myAtoi0(String str) { if (str.length() &gt; 0) { char ch = &#39; &#39;; int flag = 1; for (int i = 0; i &lt; str.length(); i++) { ch = str.charAt(i); if (ch != &#39; &#39;) { if (ch == &#39;+&#39; || ch == &#39;-&#39; || (ch - &#39;0&#39; &lt; 10 &amp;&amp; ch - &#39;0&#39; &gt;= 0)) { int begin = -1; int over = 0; if (ch == &#39;-&#39;) { flag *= -1; } if (ch - &#39;0&#39; &gt;= 0) { i--; } for (int j = i + 1; j &lt; str.length() ; j++) { ch = str.charAt(j); if (ch - &#39;0&#39; &lt; 10 &amp;&amp; ch - &#39;0&#39; &gt;= 0) { if (begin == -1) { begin = j; } over = j+1; } else { break; } } if (begin != -1) { double d = flag * Double.parseDouble(str.substring(begin, over)); if (d &lt; -2147483648) { return -2147483648; } else if (d &gt; 2147483647) { return 2147483647; } else { return (int) d; } } break; }else { break; } } } } return 0; } */ } 7.实现 strStr() 实现 strStr() 函数。 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。
思路 1)寻找needle第一个字符在haystack中出现的位置 2)判断剩余部分长度是否可能存在needle 3)判断needle是否存在
代码
class Solution { public int strStr(String haystack, String needle) { //判断输入字符串是否有效 if (needle == null || needle.length() == 0) { return 0; } for (int i = 0; i &lt; haystack.length(); i++) { //寻找needle第一个字符在haystack中出现的位置 if (haystack.charAt(i) == needle.charAt(0)) { //haystack字符串剩下部分长度大于needle，说明needle可能存在 if (haystack.length() - i &gt;= needle.length()) { //判断needle是否存在 if (testStr(haystack, needle, i)) { return i; } }else { break; } } } return -1; } /** * 判断字符串n[i,i+j]与字符串n[0,j]是否相同 * @param h 输入字符串 * @param n 输入字符串 * @param i 字符串h的开始比较的位置 * @return: true，相同；false，不相同 * @Creator: Yang YeFu * @Date: 2019/12/18 16:40 * * @Modify: Yang YeFu * @Date: 2020/2/2 17:49 */ boolean testStr(String h, String n, int i) { for (int j = 0; j &lt; n.length(); i++,j++) { if (h.charAt(i) != n.charAt(j)) { return false; } } return true; } } 8.报数 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
1 11 21 1211 111221 1 被读作 &ldquo;one 1&rdquo; (&ldquo;一个一&rdquo;) , 即 11。 11 被读作 &ldquo;two 1s&rdquo; (&ldquo;两个一&rdquo;）, 即 21。 21 被读作 &ldquo;one 2&rdquo;, &ldquo;one 1&rdquo; （&ldquo;一个二&rdquo; , &ldquo;一个一&rdquo;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。
思路 1)pre、index分别保存上一个字符和开始索引 2)当pre与下一个字符不同时，将pre出现次数及pre添加至dst中
代码
class Solution { public String countAndSay(int n) { //判断项数是否有效 if (n &lt;= 1) { return &#34;1&#34;; } //保存每项的源字符串 String src = &#34;&#34;; //保存返回字符串 StringBuilder dst = new StringBuilder(); //第一项 dst.append(1); //保存上一个字符 char pre; //保存pre开始位置 int index; for (int i = 1; i &lt; n; i++) { //将上一项结果赋予当前项 src = dst.toString(); //清除上一项结果 dst.delete(0, dst.length()); //每一项开始字符 pre = src.charAt(0); index = 0; for (int j = 0; j &lt;src.length() ; j++) { //当前字符与pre不相同 if (pre != src.charAt(j)) { //j-index为pre出现连续次数 dst.append(j - index).append(pre); //当前项赋值给pre pre = src.charAt(j); //改变所应位置 index = j; } //遍历到最后一个字符时 if (j == src.length()- 1) { dst.append(j - index + 1).append(pre); } } } return dst.toString(); } /*public String countAndSay0(int n) { if (n &lt;= 1) { return &#34;1&#34;; } int preIndex=0; int tmp=1; List&lt;Integer&gt; srcList = new ArrayList&lt;&gt;(); List&lt;Integer&gt; dstList = new ArrayList&lt;&gt;(); srcList.add(tmp); for (int i = 1; i &lt; n; i++) { dstList.clear(); for (int j = 0; j &lt; srcList.size(); j++) { if (tmp != srcList.get(j)) { dstList.add(preIndex); dstList.add(tmp); tmp = srcList.get(j); preIndex = 1; }else { preIndex++; } if (j == srcList.size() - 1) { dstList.add(preIndex); dstList.add(tmp); tmp = dstList.get(0); preIndex=0; } } if (i == n - 1) { break; } srcList.clear(); srcList.addAll(dstList); } StringBuilder dst = new StringBuilder(); for (int i = 0; i &lt; dstList.size(); i++) { dst.append(dstList.get(i)); } return dst.toString(); }*/ } 9.最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &ldquo;&quot;。 说明: 所有输入只包含小写字母 a-z 。
思路 1)顺序比较字符串数组中，相同索引的字符是否相同 2)记录索引位置i，当相同索引的字符不同时，公串为[0,i]
代码
class Solution { public String longestCommonPrefix(String[] strs) { if (strs.length == 1) { return strs[0]; } if (strs.length &gt; 1) { //储存第i个字符 char preStr; //相同字符出现的次数 int index; //第i个字符 int i = 0; for (; i &lt; strs[0].length(); i++) { //每遍历一次清零 index = 0; //第一个字符串第i个字符 preStr = strs[0].charAt(i); //第j个字符串 for (int j = 0; j &lt; strs.length; j++) { //i等于最短字符串长度，跳出 if (i == strs[j].length()) { break; } //前一个字符串的字符preStr等于下一个字符串相同索引位置的字符 if (preStr == strs[j].charAt(i)) { //preStr出现次数+1 index++; } } //当第i个字符出现次数不等于字符串数组个数，跳出，[0,i]为公串 if (index != strs.length) { return strs[0].substring(0, i); } } //遍历结束，[0,i]为公串 return strs[0].substring(0, i); } return &#34;&#34;; } /* public String longestCommonPrefix0(String[] strs) { if (strs.length == 1) { return strs[0]; } if (strs.length &gt; 1) { Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); //第i个字符 int i = 0; for (; i &lt; strs[0].length(); i++) { //第j个字符串 for ( int j = 0; j &lt; strs.length; j++) { //最短字符跳出 if (i == strs[j].length()) { break; } map.put(strs[j].charAt(i), map.getOrDefault(strs[j].charAt(i), 0) + 1); } //每个字符串中第i个字符出现的次数等于数组个数 if (map.get(strs[0].charAt(i)) != strs.length) { return strs[0].substring(0, i); } map.clear(); } //字符串完全相同 return strs[0].substring(0, i); } return &#34;&#34;; } */ } 三、链表 1.删除链表中的节点 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 &ndash; head = [4,5,1,9]，它可以表示为: 说明:
链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 思路 1)题意是删除当前节点
代码
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } 2.删除链表的倒数第N个节点 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？
思路 1)遍历得到节点数 2)找到倒数第n+1个节点 3)删除下一个节点：节点数为1时，返回null；n等于节点数时，删除首节点；n为1时，删除尾节点
代码
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { int index = 1; ListNode last = head; //遍历获取节点个数 while (last.next!= null) { last = last.next; index++; } last = head; //找到倒数n+1个节点 for (int i = 0; i &lt; index-n-1; i++) { last = last.next; } //当节点个数为1时返回null if (index == 1) { return null; } //移除最后一个节点，last.next=null if (n == 1) { last.next = null; return head; } //移除第一个节点 if (n == index) { deleteNode(last); return head; } //移除中间节点 last = last.next; deleteNode(last); return head; } public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; } } 3.反转链表 反转一个单链表。
进阶: 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
思路
​ 1)暂存下一节点tmp&lt;-last.next ​ 2)node指向last下一节点last.next&lt;-node ​ 3)last指向node，node指针前移node&lt;-last ​ 4)tmp指向last，last指针后移last&lt;-tmp
代码
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { /** * 假设head：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;null */ ListNode last = head; ListNode node = null; //迭代实现 while (last != null) { /** * 1.暂存下一节点,tmp指向last下一节点 * tmp:2-&gt;3-&gt;4-&gt;5-&gt;null */ ListNode tmp = last.next; /** * 2.last.next指向node * last-&gt;node(last.next)-&gt;null * last:1-&gt;null */ last.next = node; /** * 3.last指向node,指针前移 * node(last)-&gt;last.next(2中的node)-&gt;null * node:1-&gt;null */ node = last; /** * 4.tmp指向last,指针后移 * last:2-&gt;3-&gt;4-&gt;5-&gt;null */ last = tmp; } //递归实现 //node=revList(node,last); return node; } /** * 递归反转链表 * @param node 反向链表 * @param last 正向链表 * @return: 反转后的链表 * @Creator: Yang YeFu * @Date: 2020/2/4 14:22 * * @Modify: Yang YeFu * @Date: 2020/2/4 14:22 */ ListNode revList(ListNode node,ListNode last) { if (last != null) { ListNode tmp = last.next; last.next = node; node = last; last = tmp; return revList(node,last); } return node; } } 4.合并两个有序链表 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
思路
代码
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { //头节点 ListNode head = new ListNode(0); //获取节点位置 ListNode last = head; while (l1 != null &amp;&amp; l2 != null) { //当l1大于l2 if (l1.val &gt; l2.val) { //l2指向last下一节点 last.next=l2; //last指针后移 last = last.next; //l2指针后移 l2 = l2.next; }else { //同上 last.next=l1; last = last.next; l1 = l1.next; } } //当l1/l2指针为空，l2/l1指向last下一节点 if (l1 == null) { last.next = l2; }else { last.next = l1; } //返回链表头节点，head为初始化的0，所以返回head.next return head.next; } } 5.回文链表 请判断一个链表是否为回文链表。
思路
1)将节点添加进list，正反向比对
代码
class Solution { public boolean isPalindrome(ListNode head) { ListNode last= head; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (last != null) { list.add(last.val); last = last.next; } for (int i = 0,j=list.size()-1; i &lt; j; i++,j--) { if (!list.get(i).equals(list.get(j))) { return false; } } return true; } } 6.环形链表 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
思路
1)题意：给定链表头节点，判断链表中是否有环 2)方法一：置空法。设置一个标志，遍历每个节点，当节点val不等于标志时，使其等于标志。当出现标志，说明有环；当出现节点为null，说明没有环 链表数据被破环，标志值必须是链表中不存在的值 3)方法二：hash。遍历head，将每个节点添加进set，当set中存在当前节点，说明有环 比较耗费时间 4)方法三：快慢指针，当快指针等于慢指针时，存在环，当快指针为null时，没有环。 这个方法始终写好之后始终通不过测试，或者超出时间限制。
class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } //置空法 while(head!=null){ if (head.val == 19970803) { return true; } head.val = 19970803; head = head.next; } return false; } public boolean hasCycle0(ListNode head) { //hash Set&lt;ListNode&gt; set = new HashSet&lt;&gt;(); while (head != null) { if (set.contains(head)) { return true; } set.add(head); head = head.next; } return false; } } 四、树 ]]></content></entry><entry><title>安装配置Hive&MySQL</title><url>/post/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEhive-mysql/</url><categories/><tags><tag>Hive</tag><tag>MySQL</tag><tag>hadoop</tag></tags><content type="html"><![CDATA[~第五部分，未完待续（如果有时间的话）~
以下是参考课堂上及助教发的教程，实际操作之后整理而来
​
安装配置Hive&amp;mariadb（MySQL分支）一、准备工作 Linux环境：Centos 7
远程登陆：xShell 6
1）登录服务器
vim命令（默认已经会了）
启动hadoop
二、下载&amp;安装配置Hive（所有涉及到路径的地方，按照实际情况填） 下载Hive-3.1.1，选择清华源。查看Hive与Hadoop版本对应点这里wget https://mirrors.tuna.tsinghua.edu.cn/apache/hive/hive-3.1.1/apache-hive-3.1.1-bin.tar.gz 解压
tar -zxvf apache-hive-3.1.1-bin.tar.gz -C /usr/local/ 配置环境变量
vi /etc/profile 将下面的内容添加至文末
export HIVE_HOME=/usr/local/apache-hive-3.1.1-bin export PATH=$PATH:$HIVE_HOME/bin 使环境变量生效
source /etc/profile 配置Hive
切到/usr/local/apache-hive-3.1.1-bin/conf目录
cd /usr/local/apache-hive-3.1.1-bin/conf 1）拷贝模板配置
cp hive-default.xml.template hive-default.xml cp hive-env.sh.template hive-env.sh 2）配置hive-env.sh
vi hive-env.sh 在文末添加以下内容
export JAVA_HOME=/usr/local/jdk1.8.0_181 export HIVE_HOME=/usr/local/apache-hive-3.1.1-bin export HADOOP_HOME=/usr/local/hadoop-3.1.2 3）创建并配置hive-site.xml
vi hive-site.xml 添加以下内容(第6行，端口前地址改为自己的主机名或者ip)
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; standalone=&#34;no&#34;?&gt; &lt;?xml-stylesheet type=&#34;text/xsl&#34; href=&#34;configuration.xsl&#34;?&gt; &lt;configuration&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt; &lt;value&gt;jdbc:mysql://ct01:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt; &lt;description&gt;JDBC connect string for a JDBC metastore &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt; &lt;value&gt;hive&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.querylog.location&lt;/name&gt; &lt;value&gt;/usr/local/apache-hive-3.1.1-bin/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.exec.local.scratchdir&lt;/name&gt; &lt;value&gt;/usr/local/apache-hive-3.1.1-bin/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hive.downloaded.resources.dir&lt;/name&gt; &lt;value&gt;/usr/local/apache-hive-3.1.1-bin/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;datanucleus.schema.autoCreateAll&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 4）如果/usr/local/apache-hive-3.1.1-bin/没有临时文件夹tmp，创建tmp临时文件夹
cd .. mkdir tmp 5）下载MySQL的jdbc包，拷贝到/usr/local/apache-hive-3.1.1-bin/lib
下载&amp;解压mysql-connector-java-5.1.47.tar.gz
cd ~ wget https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.47.tar.gz tar -zxvf mysql-connector-java-5.1.47.tar.gz 拷贝至/usr/local/apache-hive-3.1.1-bin/lib
cp mysql-connector-java-5.1.47/mysql-connector-java-5.1.47-bin.jar /usr/local/apache-hive-3.1.1-bin/lib 三、下载&amp;安装配置MySQL 查看是否已经安装MySQL
rpm -qa | grep mysql 如果有则卸载
rpm -e --nodeps 包名 yum安装MySQL
1）搜索软件包
yum search mariadb 这里搜索mysql-server会给一个akonadi-mysql.x86_64，如果安装这个的话，mariadb.x86_64也会被一起安装，可以，但是没有必要。
2）根据搜索到的软件包安装mariadb-server.x86_64 ，mariadb是MySQL的一个分支
yum install mariadb-server.x86_64 查看mariadb状态、启动、关闭、重启、开机启动MySQL服务
systemctl status mariadb systemctl start mariadb systemctl stop mariadb systemctl restart mariadb systemctl enable mariadb 配置MySQL
1）启动mariadb服务
systemctl start mariadb 2）初始化（root密码要与hive-site.xml配置中的密码一致）
mysql_secure_installation Enter current password for root (enter for none):&lt;–初次运行直接回车
设置密码
Set root password? [Y/n] &lt;– 是否设置root用户密码，输入y并回车或直接回车 New password: &lt;– 设置root用户的密码 Re-enter new password: &lt;– 再输入一次你设置的密码
其他配置
Remove anonymous users? [Y/n] &lt;– 是否删除匿名用户，回车
Disallow root login remotely? [Y/n] &lt;–是否禁止root远程登录,n回车,
Remove test database and access to it? [Y/n] &lt;– 是否删除test数据库，回车
Reload privilege tables now? [Y/n] &lt;– 是否重新加载权限表，回车
3）登录MySQL
mysql -u root -p 4）创建hive数据库
MariaDB [(none)]&gt; create database hive; 5）允许hive接入（最后的hive为数据库密码，与hive-site.xml配置中一致）
MariaDB [(none)]&gt; grant all on *.* to hive@localhost identified by &#39;hive&#39;; 6）刷新MySQL系统权限关系
MariaDB [(none)]&gt; flush privileges; 7）退出
MariaDB [(none)]&gt; exit; Bye
四、初始化&amp;启动Hive&amp;创建一个数据库 初始化Hive
schematool -initSchema -dbType mysql 出现以下信息说明成功
schemaTool completed
启动Hive
hive 创建数据库
hive&gt; create database hive; 查看创建好的数据库
hive&gt; show databases; 五、遇到的问题 启动hive时可能提示错误，再启动一次就ok ]]></content></entry><entry><title>编译打包运行MapReduce程序_WordCount.java_FileSystemCat.java</title><url>/post/%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85%E8%BF%90%E8%A1%8Cmapreduce%E7%A8%8B%E5%BA%8F-wordcount-java/</url><categories/><tags><tag>hadoop</tag></tags><content type="html"><![CDATA[继上一篇hadoop配置，编译打包运行第一个MapReduce程序：WordCount.java
视频比博客先完成，所以博客是整理视频内容
编译打包运行MapReduce程序_WordCount.java一、准备工作
Linux环境：Centos 7
远程登陆：xShell 6
1）登录服务器
vim命令（默认已经会了）
启动hadoop
1）添加hadoop classpath
vi /etc/profile 在文末添加以下内容
export CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath):$CLASSPATH 保存退出，使环境变量生效
source /etc/profile 2）配置yarn-site.xml，不然会出现以下错误
错误: 找不到或无法加载主类 org.apache.hadoop.mapreduce.v2.app.MRAppMaster 查看hadoop classpath，复制出现的内容
hadoop classpath 在yarn-site.xml中添加以下的内容，classpath改为复制的内容
&lt;property&gt; &lt;name&gt;yarn.application.classpath&lt;/name&gt; &lt;value&gt;classpath&lt;/value&gt; &lt;/property&gt; 重启yarn
stop-yarn.sh start-yarn.sh hadoop fs命令（默认已经会了）
二、上传&amp;编译&amp;打包&amp;运行
上传WordCount.java文件到服务器，方法很多简述2种
1）方法一：安装lrzsz,用rz、sz进行上传下载
yum search lrzsz 根据查找到的包名进行安装，按提示输入y
yum install lrzsz.x86_64 安装完成后输入rz，回车，选择要上传的文件，上传完后ls查看文件是否存在
2）方法二：直接创建WordCount.java
vi WordCount.java 将代码复制粘贴，保存退出
编译、打包
1）编译WordCount.java
javac WordCount.java 2）将.class打包成jar
jar -cvf WordCount.jar ./WordCount*.class ls可看到编译、打包的文件
准备运行MapReduce程序
1）创建几个测试文件，这里就只创建一个
mkdir test vi test/filetest 随便输入几个单词，以空格或者逗号作为间隔，完成后保存退出
2）本地文件上传到伪分布式HDFS上
hadoop fs -put ./test /input 如果提示没有input目录，先创建input目录
hadoop fs -mkdir /input 3）运行MapReduce程序
hadoop jar WordCount.jar org/apache/hadoop/examples/WordCount /input /output 等待运行完
查看运行结果
查看/output目录是否相应的文件
hadoop fs -ls /output 应该出现以下内容
Found 2 items -rw-r&ndash;r&ndash; 1 root supergroup 0 2019-05-26 21:30 /user/root/output/_SUCCESS -rw-r&ndash;r&ndash; 1 root supergroup 26 2019-05-26 21:30 /user/root/output/part-r-00000
查看运行结果
hadoop fs -cat /output/part-r-00000 结果如下
1234 1 had 1 ooo 1 test 1
五、可能出现的问题
执行 二 - 3 - 3）步时，提示input目录下没有文件
此时应该查看是否上传成功，或者说文件在/input/test目录下
hadoop fs -ls /input 1）如果在test目录下，执行
hadoop jar WordCount.jar org/apache/hadoop/examples/WordCount /input/test /output 此时有可能提示/output目录已存在，删除后重新执行以上命令
hadoop fs -rm -r /output virtial memory limit（虚拟内存限制）
配置yarn-site.xml，重启yarn，再重新执行 二 - 3 - 3）步
具体怎么配置自己百度吧。
应该用以下2个方法：
1）关闭yarn对应用虚拟内存的检查
2）配置yarn-site.xml，自行设置虚拟内存
Retrying connect to server（一直重连）
检查hadoop是否正常启动
jps 编译&amp;打包&amp;运行FileSystemCat.java 上传文本到HDFS
切到java文件所在目录
编译
javac File*.java 打包
jar -cvf FileSystemCat.jar File*.class 执行，path改为HDFS一个指向文本的路径
hadoop jar FileSystemCat.jar FileSystemCat path ]]></content></entry><entry><title>Centos7配置hadoop3.1.2伪分布式详细过程</title><url>/post/centos7%E9%85%8D%E7%BD%AEhadoop3.1.2-%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/</url><categories/><tags><tag>Centos</tag><tag>hadoop</tag></tags><content type="html"><![CDATA[ VMware&amp;CentOS7安装配置hadoop-3.1.2全过程一、准备工作 Linux环境：Centos 7
远程登陆：xShell 6
1）登录服务器
vim命令（默认已经会了），只贴本文用到的
vi 文件名 打开文件
i 编辑
Esc 退出编辑
:wq 保存并退出
键盘控制光标上下左右
二、检查&amp;安装JDK 检查系统是否存在openjdk rpm -qa | grep java 若有java相关的软件显示，则表示存在，进行卸载：
rpm -e --nodeps jdk 软件名称 若没有显示，则不存在。
下载&amp;解压jdk 1）下载jdk：
wget --no-check-certificate --no-cookies --header &#34;Cookie: oraclelicense=accept-securebackup-cookie&#34; jdk下载地址 例如：
wget --no-check-certificate --no-cookies --header &#34;Cookie: oraclelicense=accept-securebackup-cookie&#34; https://download.oracle.com/otn-pub/java/jdk/12.0.1+12/69cfe15208a647278a19ef0990eea691/jdk-12.0.1_linux-x64_bin.tar.gz 这里的链接已失效，建议自己下载到电脑，然后上传至虚拟机。
这里下载jdk8，因为使用jdk9及以上版本，启动Hadoop时会出现难以解决的问题，我搜索尝试了很多办法，得出结论:目前没有办法通过配置文件解决。
wget http://111.1.50.20/files/4041000006F611C7/download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz 如果没有wget命令，执行
yum search wget 查找到软件包后，执行
yum install 检索到的软件包 如有确认，按提示输入y或yes。
2）解压jdk，解压到哪个目录可以自行选择，但是要知道路径，配置环境变量时需要
tar -zxvf jdk压缩包名称 -C 解压到哪个目录 例如：
tar -zxvf jdk-8u181-linux-x64.tar.gz -C /usr/local/ 配置环境变量 1）打开proflie文件
vi /etc/profile 2）将光标移动至文末，按i进入编辑模式，在文末添加以下内容
export JAVA_HOME=jdk路径 export PATH=$PATH:$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 例如：
export JAVA_HOME=/usr/local/jdk1.8.0_181 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 3）按Esc键退出编辑，输入 ：wq 保存并退出文件，执行以下内容使环境变量生效
source /etc/profile 检查jdk是否安装配置成功 java -version 出现java版本信息，则配置成功，例如
java version &ldquo;1.8.0_181&rdquo; Java(TM) SE Runtime Environment (build 1.8.0_181-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
三、配置Hadoop 下载hadoop wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz 解压hadoop，解压到哪个目录可以自行选择，但是要知道路径，配置环境变量时需要 tar -zxvf hadoop-3.1.2.tar.gz -C /usr/local/ 配置hadoop（本文涉及到的ct01，均需要改为自己的主机名或者ip） 1）配置环境变量
vi /etc/profile 按i进入编辑模式，在文末添加
export HADOOP_HOME=/hadoop路径 export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 例如
export HADOOP_HOME=/usr/local/hadoop-3.1.2 export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 按Esc退出编辑，输入 :wq 保存并退出，执行以下内容使环境变量生效
source /etc/profile 2）配置hadoop-env.sh
切到/usr/local/hadoop-3.1.2/etc/hadoop目录下，2）- 6）都是在这个目录下配置
cd /usr/local/hadoop-3.1.2/etc/hadoop 打开hadoop-env.sh
vi hadoop-env.sh 找到# export JAVA_HOME=,按i进入编辑模式，修改为以下内容后，按Esc，输入 :wq 保存并退出
export JAVA_HOME=/usr/local/jdk1.8.0_181 3）配置core-site.xml，修改为以下内容，其中第5行 ct01 改为自己的主机名
&lt;configuration&gt; &lt;!--设置namenode所在节点--&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://ct01:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 设置hadoop存放数据的目录，Hadoop默认把数据块的元数据和数据存放在操作系统的/tmp目录下，但操作系统的/tmp目录会不定时清空，所以要做修改 --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/local/hadoop-3.1.2/data&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 4）配置yarn-site.xml，修改为以下内容，ct01 均改为自己的主机名
&lt;configuration&gt; &lt;!-- 指定ResourceManager的地址--&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;ct01&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;ct01:8032&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;ct01:8030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;ct01:8031&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;ct01:8033&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;ct01:8088&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定reducer获取数据的方式--&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 5）配置hdfs-site.xml，修改为以下内容
&lt;configuration&gt; &lt;!--设置block副本数，不能超过节点数--&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 6）配置mapred-site.xml，修改为以下内容
&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;/configuration&gt; 7）配置start-dfs.sh，stop-dfs.sh
切到/usr/local/hadoop-3.1.2/sbin目录,7）- 8）在这个目录配置
cd /usr/local/hadoop-3.1.2/sbin 在start-dfs.sh，stop-dfs.sh第二行添加以下内容，因为是root登录的，不配置会出现错误
HDFS_DATANODE_USER=root HDFS_DATANODE_SECURE_USER=hdfs HDFS_NAMENODE_USER=root HDFS_SECONDARYNAMENODE_USER=root 8）配置start-yarn.sh，stop-yarn.sh，在第二行添加以下内容
YARN_RESOURCEMANAGER_USER=root HADOOP_SECURE_DN_USER=yarn YARN_NODEMANAGER_USER=root 实现SSH免密码远程登录，因为是伪分布式集群，其实就是自己登录自己（如果已经配置过可跳过） 1）创建公钥/私钥，一路回车
ssh-keygen -t rsa 2）创建authorized_keys文件并修改权限为600
cd ~/.ssh touch authorized_keys chmod 600 authorized_keys 3）将公钥追加到authorized_keys文件中
cat id_rsa.pub &gt;&gt; authorized_keys 尝试能否免密登录，能登陆就成功了，尝试后，输入exit退出
ssh 自己的主机名 关闭防火墙（如果已经配置过可跳过） 查看防火墙状态
firewall-cmd --state 1）关闭防火墙
systemctl stop firewalld.service 2）禁止开机时防火墙自启
systemctl disable firewalld.service 四、格式化&amp;启动&amp;停止hadoop 格式化hadoop，不要多次格式化。多次格式化会导致DataNode无法正常启动，解决办法在文末 hadoop namenode -format 启动&amp;停止hadoop start-all.sh stop-all.sh 启动以后可以输入jps，看有没有下面这些进程
16352 NameNode 21362 Jps 16644 SecondaryNameNode 17017 NodeManager 16475 DataNode 16891 ResourceManager 输入netstat -tpnl | grep java，查看是否有9870和8088端口，刚启动需要等待一会儿才能查询到端口，等待时间视虚拟机情况而定
netstat -tpnl | grep java 可以在浏览器访问ip:9870和ip:8088
五、遇到的一些坑 多次格式化会导致DataNode无法正常启动（很多人遇到这个问题） 1）打开/usr/local/hadoop-3.1.2/data/dfs
cd /usr/local/hadoop-3.1.2/data/dfs 2）有name和data两个目录，将data/current/VERSION中clusterID的值改为name/current/VERSION中clusterID的值
找到并复制clusterID的值
cat name/current/VERSION 修改clusterID的值
vi data/current/VERSION 3）重新启动hadoop
ip:50070无法访问 hadoop 3.X版本以上，50070端口已改为9870端口，访问ip：9870即可
解决问题的最好办法 查看logs！如果看不懂请百度。修改之后记得重启hadoop
以本文为例，logs路径为：/usr/local/hadoop-3.1.2/logs
]]></content></entry><entry><title>About</title><url>/about/</url><categories/><tags/><content type="html"> Stand up for something, even if it means standing alone sometimes.
About ​ 这个博客的用于记录一些生活、学习中的东西
Contact ​ · Email: chn.yyf@gmail.com
Marker 毕业后开始考公之路，希望能有个好结果 2022.12.31已通过面试</content></entry></search>